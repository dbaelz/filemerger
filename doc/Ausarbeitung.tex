\documentclass[a4paper,titlepage,12pt]{scrartcl}

% utf-8
\usepackage{polyglossia}
\setdefaultlanguage[babelshorthands]{ngerman}
\usepackage{fontspec}

% german names
\usepackage{ngerman}

% colored links
\usepackage{color}
\usepackage[colorlinks]{hyperref}
% custom colors
\definecolor{grey}{rgb}{0.2,0.2,0.2}
\definecolor{orange}{rgb}{1,0.3,0}
\definecolor{turqoise}{rgb}{0,0.7,0.5}

% code listings
\usepackage{listings}
\lstset{%
	basicstyle={\ttfamily \small},
	breaklines=true,
	commentstyle=\color{grey},
	keywordstyle=\color{orange},
	language=C,
	numbers=left,
	showspaces=false,
	stringstyle=\color{turqoise},
	xleftmargin=20pt
}

% graphics
\usepackage{graphicx}
\graphicspath{img/}

% fancy headers and footers
\usepackage{fancyhdr}
\pagestyle{fancy}
% clear style
\fancyhead{}
\fancyfoot{}
% new style
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\fancyhead[LE,RO]{\rightmark}
\fancyhead[LO,RE]{\leftmark}
\fancyfoot[LE,RO]{\thepage}
\fancyfoot[LO,RE]{Qualtitätssicherung Wintersemester 2012/2013}
\fancypagestyle{plain}{%
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
	\renewcommand{\footrulewidth}{0.5pt}
	\fancyfoot[LE,RO]{\thepage}
	\fancyfoot[LO,RE]{Qualtitätssicherung Wintersemester 2012/2013}
}

% no indented paragraphs
\usepackage{parskip}

\setkomafont{disposition}{\normalfont\bfseries}

\usepackage{natbib}

\usepackage{amsfonts}

\usepackage{verbatim}

\begin{document}

\titlehead{%
	\includegraphics[width=0.9\linewidth]{img/hska_logo.png}
}

\title{Qualitätssicherung}
\author{%
	Daniel Bälz, Mat.-Nr.: 31074 \\
	Fabian Freimüller, Mat.-Nr.: 30684 \\
}
\date{Wintersemester 2012/2013}
\publishers{%
    \textbf{Betreuer:} Prof.\,Dr. Dirk W. Hoffmann
}
\maketitle

\tableofcontents

\clearpage

\section{Einleitung}
\label{sec:intro}
Ziel der Blockveranstaltung Qualitätssicherung ist es, in die Thematik der Software-Qualitätssicherung einzuführen. Kombiniert wird hierbei die Vorlesung mit einer praktischen Aufgabe, die einen Teilbereich des Vorlesungsinhalts umsetzt. Im Rahmen der Vorlesung wurde erläutert wie aus zwei gegebenen Sequenzen die Längste gemeinsame Teilfolge (LGT) mit einer maximalen Komplexität von $O(n^2)$ ermittelt wird. Mit Hilfe dieser Teilfolge ist es möglich eine Verschmelzung von Dateien durchzuführen und eine Teilmenge der entstehenden Konflikte automatisiert zu lösen.
Aufbauend auf die in der Vorlesung gelehrten Konzepte bestand die erste Aufgabe daraus, ein Programm zur Verschmelzung von zwei unabhängig weiterentwickelten Revision V1 und V2 aus der Ausgangsdatei V selbstständig ohne Zuhilfenahme bestehender Verschmelzungs-Algorithmen zu implementieren. Auftretende Konflikte sollten wenn möglich automatisiert gelöst werden. Im Fall von nicht lösbaren Konflikten soll der Anwender über den Konflikt informiert werden, so dass er eine manuelle Verschmelzung vornehmen kann.
Die zweite Aufgabe bestand daraus, dass in der ersten Aufgabe enstandene Programm mittels geeigneter Testfälle und eines Programms zur Überprüfung der Zeilenabdeckung zu testen.

\section{Wahl der Programmiersprache}
\label{sec:proglang}
Für die Aufgaben war die Implementierungssprache freigestellt, so fern beide Aufgaben unter den oben genannten Bedingungen mit der Sprache realisierbar waren. Aufgrund der Tatsache, dass beide Gruppenmitglieder in der Programmierung mit Java die größte Erfahrung haben und Toolunterstützung zum Test der Zeilenabdeckung vorhanden ist wurde diese Programmiersprache gewählt.

\section{Design der Benutzerschnittstellen}
\label{sec:design}
Um das Programm möglichst flexibel verwenden zu können wurde es als Kommandozeilenprogramm gestaltet.
Das Programm übernimmt als Parameter die drei benötigten Dateien, mit deren Hilfe die Drei-Wege-Verschmelzung durchgeführt wird. Das Programms kann in der Kommandozeile wie folgt aufgerufen werden:

\lstset{language=sh, numbers=none, xleftmargin=0pt}
\begin{lstlisting}
java -jar FileMerger V.txt V1.txt V2.txt
\end{lstlisting}
Wie dem Dateinamen zu entnehmen ist handelt es sich beim ersten Parameter um die Ausgangsdatei V, die beiden folgenden Parameter stellen die zu verschmelzenden Revisionen V1 und V2 dar. Dies wiederspricht der bei diff3 gängigen Reihenfolge V1, V, V2. Da die hier gewählte Reihenfolge den Gruppenmitgliedern natürlicher in der Benutzung erschien wurde sie anstelle des bei diff3 üblichen Schema gewählt.

Das Ergebnis der Verschmelzung wird vom Programm auf der Standardausgabe ausgegeben. Konflikte werden hierbei unter Angabe der konfliktbehafteten Stelle in folgender Form angezeigt:

\begin{verbatim}
Merge Error: File2: ABC and File3: DEF
\end{verbatim}


Die Ausgabe wird nicht in eine Datei geschrieben. Bei gewünschter Speicherung in eine Datei wird der Benutzer angehalten, die Ausgabe selbst mittels Ausgabeumleitung in eine Datei zu schreiben.

\section{Algorithmus}
\label{sec:algorithm}
<TODO: Theorie und Algorithmus des LGT mit Verweis auf \citet{www:EP96}>
Der Merger baut auf die Längste gemeinsame Teilfolge der Zeilen, von allen drei Dateiversionen, auf und kümmert sich um die darauffolgenden Konflikte.

Zur Ermittlung der längsten gemeinsamen Teilfolge, verwendeten wir den in \citet{www:EP96}> beschriebenen Algorithmus, und nutzt die aufsteigende dynamische Programmierung.
Der beschriebene Algorithmus bekommt, in unserem Fall, 2 Listen als Eingabeparameter.
Zunächst wird eine Matrix erstellt in der die Vergleichsresultate der einzelnen Listenelemente gespeichert sind.
Die Iteration durch die genullte Matrix erfolgt aufsteigend, sie beginnt somit unten rechts und endet oben links.
Mit einer Übereinstimmung zweier Listenelemente wird der Wert, abhängig vom diagonal unterliegendes Feldes, um 1 erhöht.
Bei keiner weiteren Übereinstimmung erhalten die anderen Felder den Wert des rechts oder unten angrenzenden Feldes.
Am Ende des Durchlaufes steht somit im ersten Feld der Matrix die Länge der längsten gemeinsamen Teilfolge.

Um nun die längste gemeinsame Teilfolge zu ermitteln muss erneut über die gewonnene Matrix und die einzelnen Listenelemente der Eingabeparameter iteriert werden.
Hierfür werden die diagonalen Übergänge in der Matrix gesucht, da dort die Listenelemente übersteinstimmen, diese werden nun zum Ergebnis hinzugefügt.

Der beschriebene Algorithmus ermittelt den LGT innerhalb von $O(nm)$ , bei unterschiedlich langen Dateien, und in $O(n^2)$ bei gleich langen Dateien, somit erfüllt der Algorithmus die gewünschte
Laufzeitforderung.


\section{Implementierung}
\label{sec:implementation}
Für die Implementierung des Algorithmus in einem lauffähigen Programm wurden in Java zwei Klassen erstellt.

\subsection{Klasse Main}
\label{sec:classmain}
Die Klasse Main enthält als statische Methode die main-Methode, welche die Parameter übergeben bekommt. Dieser Methode obliegt es, die Parameter auf ihre Korrektheit zu prüfen und anschließend die in File-Objekte gewandelten Dateien an die die Verschmelzung durchführende Klasse weiter zu geben. Auch die Ausgabe des Verschmelzungsergebnis und eines eventuell notwendige Warnhinweises im Konfliktfall wird in dieser Klasse durchgeführt.

\subsection{Klasse Merge}
\label{sec:classmerge}
Die Erstellung des LGT und die darauf aufbauenden Verschmelzung der Dateien V1 und V2 ist Aufgabe der Klasse Merge. Diese nimmt aus der oben genannten Klasse Main die File-Objekte entgegen und liest deren Inhalt zeilenweise ein. Beim Einlesen werden die Zeilen jeweils als SHA-1 Hash in eine ArrayList abgespeichert.

\texttt{lcs(List<String> list1, List<String> list2)}
Die lcs-Methode benutzt den oben beschriebenen Algorithmus, sie bekommt 2 Listen als Eingabeparameter übergeben und gibt die längste gemeinsame Teilfolge ebenfalls als Liste zurück.


\texttt{merge()}
Für die Beschreibung der Methode sollen nun folgende Konventionen gelten:
\begin{itemize}
\item $V1 , V2$ und $S$ beschreiben die beiden geänderten Dateien/Listen und die Ausgangsdatei/Liste.
\item $L_V1_S$ sei die längste Gemeinsame Teilfolge von $V1$ und $S$
\item $L_V2_S$ sei die längste Gemeinsame Teilfolge von $V2$ und $S$
\item $L_Ges$ sei die längste Gemeinsame Teilfolge von $L_V1_S$ und $L_V2_S$
\end{itemize}

Die merge-Methode benutzt die oben genannten LGT-Ergebnisse und versucht mit diesen die Dateien/Listen zu mergen indem die Methode über die einzelnen Elemente der geänderten Dateien/Listen iteriert.
Das Ergebnis wir ebenfall in einer Liste gespeichert.
Zur Ermittlung des Ergebnisses wird folgendes solange durchgeführt bis kein Element in einer der Listen verbleibt:
\begin{itemize}
\item Wenn $V1(i) = V2(j)$ gilt, füge die Zeile dem Ergebnis hinzu
\item Ist $V1(i) = L_Ges(m)$ , füge die Zeile $V2(j)$ dem Ergebnis hinzu, da diese neu eingefügt wurde.
\item Ist $V2(j) = L_Ges(m)$, füge die Zeile $V1(i)$ dem Ergebnis hinzu.
\item Wenn $V1(i) = L_V1_S(k)$ gilt, füge $V2(j)$ dem Ergebnis hinzu, da $V1$ die Zeile beibehalten hat und in $V2$ eine Änderung stattfand.
\item Wenn $V2(j) = L_V2_S(l)$ gilt, füge $V1(i)$ dem Ergebnis hinzu, da $V2$ die Zeile beibehalten hat und in $V1$ eine Änderung stattfand.
\item Der Letze Fall beschreibt einen Merge-Konflikt da sowohl $V1(i)$ als auch $V2(j)$ neu eingefügt worden sind, deshalb werden beide Zeilen mit der in Abschnitt~\ref{sec:design} beschriebenen Notation dem Ergebnis hinzugefügt.
\end{itemize}
Enthält eine Liste keine Elemente mehr, ist die andere Liste länger. Somit werden die Elemente der längeren Liste dem Ergebnis hinzugefügt.



\section{Test}
\label{sec:test}
<TODO: Test der Zeilenabdeckung mit eclemma>

<TODO: Zusammenführung der Testergebnisse um 100\% Zeilenabdeckung zu erreichen>


\clearpage
\appendix

\bibliographystyle{plainnat}
\bibliography{EP96}

\end{document}